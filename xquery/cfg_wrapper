date=$(date "+%Y/%m/%d %H:%M:%S")

if [ -z "$BASH_SOURCE" ]; then
BASH_SOURCE=$0
RUN_OR_SOURCE=RUN
else
RUN_OR_SOURCE=SOURCE
fi

enum_prologue()
{
cat << EOF
/*
 * Auto-generated by $BASH_SOURCE
 * date: $date
 *
 * DO NOT MODIFY.
 */
#ifndef __CFG_ENUM_H__
#define __CFG_ENUM_H__

EOF
}

header_prologue()
{
cat << EOF
/*
 * Auto-generated by $BASH_SOURCE
 * date: $date
 *
 * DO NOT MODIFY.
 */
#ifndef __CFG_WRAPPER_H__
#define __CFG_WRAPPER_H__

#include <os_port.h>
#include <tool_api.h>
#include <provision_db_desc.h>

#define CFG_WRAPPER_XQUERY

#define GET_U16_BYTE1(data)		((OpU8)((data & 0xFF00) >> 8))
#define GET_U16_BYTE2(data)		((OpU8)(data & 0x00FF))

#define GET_U32_BYTE1(data)		((OpU8)((data & 0xFF000000) >> 24))
#define GET_U32_BYTE2(data)		((OpU8)((data & 0x00FF0000) >> 16))
#define GET_U32_BYTE3(data)		((OpU8)((data & 0x0000FF00) >> 8))
#define GET_U32_BYTE4(data)		((OpU8)(data & 0x000000FF))

#define ENUM_BASIC_TYPES \\
ENUM_TYPE(U8, U8, OpU8) \\
ENUM_TYPE(U16, U16, OpU16) \\
ENUM_TYPE(U32, U32, OpU32) \\
ENUM_TYPE(S8, S8, OpS8) \\
ENUM_TYPE(S16, S16, OpS16) \\
ENUM_TYPE(S32, S32, OpS32) \\
ENUM_TYPE(FLOAT, FLOAT, FLOAT)

#define ENUM_ARRAY_TYPES \\
ENUM_TYPE(MAC, MAC, OpU8) \\
ENUM_TYPE(STRING, STRING, OpS8)

#define ENUM_DUMMY_BASIC_TYPES \\
ENUM_TYPE(ABLE, U8, OpU8) \\
ENUM_TYPE(YN, U8, OpU8) \\
ENUM_TYPE(IPV4, U32, OpU32) \\
ENUM_TYPE(IPV4MASK, U32, OpU32) \\
ENUM_TYPE(LIST, U32, OpU32) \\
ENUM_TYPE(RELATION, U32, OpU32)

#define ENUM_DUMMY_ARRAY_TYPES \\
ENUM_TYPE(FILESELECT, STRING, OpS8) \\
ENUM_TYPE(PASSWD, STRING, OpS8)

#define DECL_STD_ARGS	eProvisionDbDesc tag, OpU16 id1, OpU16 id2
#define STD_ARGS		tag, id1, id2

#define DECL_PROV_ARGS(type)		type * data, OpU16 dataSize
#define DECL_DOT_PROV_ARGS(type)	, DECL_PROV_ARGS(type)
#define PROV_ARGS					data, dataSize

#define DECL_PROV_GET(ret, name1, name2, type) \\
ret ProvGet##name1        ( DECL_STD_ARGS, DECL_PROV_ARGS(type), OpBool current              ) BODY_GET          (name2, type) \\
ret ProvGetTmp##name1     ( DECL_STD_ARGS, DECL_PROV_ARGS(type)                              ) BODY_GET_TMP      (name2, type) \\
ret ProvGetByKey##name1   ( DECL_STD_ARGS, DECL_PROV_ARGS(type), OpBool current, OpU16 key   ) BODY_GET_BYKEY    (name2, type) \\
ret ProvGetTmpByKey##name1( DECL_STD_ARGS, DECL_PROV_ARGS(type), OpU16 key                   ) BODY_GET_TMP_BYKEY(name2, type) \\
ret ProvGetByIndex##name1 ( DECL_STD_ARGS, DECL_PROV_ARGS(type), OpBool current, OpU16 index ) BODY_GET_BYINDEX  (name2, type)

/* ----- ProvGet ----- */

#define BODY_GET(name, type)			;
#define BODY_GET_TMP(name, type)		;
#define BODY_GET_BYKEY(name, type)		;
#define BODY_GET_TMP_BYKEY(name, type)	;
#define BODY_GET_BYINDEX(name, type)	;
#define ENUM_TYPE(dummy, real, type)	DECL_PROV_GET(int, real, real, type)

ENUM_BASIC_TYPES
ENUM_ARRAY_TYPES

#undef ENUM_TYPE
#undef BODY_GET
#undef BODY_GET_TMP
#undef BODY_GET_BYKEY
#undef BODY_GET_TMP_BYKEY
#undef BODY_GET_BYINDEX

#define BODY_GET(name, type)			{ return ProvGet##name( STD_ARGS, PROV_ARGS, current ); }
#define BODY_GET_TMP(name, type)		{ return ProvGetTmp##name( STD_ARGS, PROV_ARGS ); }
#define BODY_GET_BYKEY(name, type)		{ return ProvGetByKey##name( STD_ARGS, PROV_ARGS, current, key ); }
#define BODY_GET_TMP_BYKEY(name, type)	{ return ProvGetTmpByKey##name( STD_ARGS, PROV_ARGS, key ); }
#define BODY_GET_BYINDEX(name, type)	{ return ProvGetByIndex##name( STD_ARGS, PROV_ARGS, current, index ); }
#define ENUM_TYPE(dummy, real, type)	DECL_PROV_GET(static inline int, dummy, real, type)

ENUM_DUMMY_BASIC_TYPES
ENUM_DUMMY_ARRAY_TYPES

#undef ENUM_TYPE
#undef BODY_GET
#undef BODY_GET_TMP
#undef BODY_GET_BYKEY
#undef BODY_GET_TMP_BYKEY
#undef BODY_GET_BYINDEX

/* ----- CfgGet ----- */

#define DECL_CFG_GET(ret, name1, name2, type, ...) \\
static inline ret CfgGet##name1        ( DECL_STD_ARGS __VA_ARGS__, OpBool current              ) BODY_GET          (ProvGet##name2,         type) \\
static inline ret CfgGetTmp##name1     ( DECL_STD_ARGS __VA_ARGS__                              ) BODY_GET_TMP      (ProvGetTmp##name2,      type) \\
static inline ret CfgGetByKey##name1   ( DECL_STD_ARGS __VA_ARGS__, OpBool current, OpU16 key   ) BODY_GET_BYKEY    (ProvGetByKey##name2,    type) \\
static inline ret CfgGetTmpByKey##name1( DECL_STD_ARGS __VA_ARGS__, OpU16 key                   ) BODY_GET_TMP_BYKEY(ProvGetTmpByKey##name2, type) \\
static inline ret CfgGetByIndex##name1 ( DECL_STD_ARGS __VA_ARGS__, OpBool current, OpU16 index ) BODY_GET_BYINDEX  (ProvGetByIndex##name2,  type)

#define BODY_GET(name, type)			{ type data = 0; name( STD_ARGS, &data, sizeof (data), current        ); return data; }
#define BODY_GET_TMP(name, type)		{ type data = 0; name( STD_ARGS, &data, sizeof (data)                 ); return data; }
#define BODY_GET_BYKEY(name, type)		{ type data = 0; name( STD_ARGS, &data, sizeof (data), current, key   ); return data; }
#define BODY_GET_TMP_BYKEY(name, type)	{ type data = 0; name( STD_ARGS, &data, sizeof (data), key            ); return data; }
#define BODY_GET_BYINDEX(name, type)	{ type data = 0; name( STD_ARGS, &data, sizeof (data), current, index ); return data; }
#define ENUM_TYPE(dummy, real, type)	DECL_CFG_GET(type, dummy, real, type)

ENUM_BASIC_TYPES
ENUM_DUMMY_BASIC_TYPES

#undef ENUM_TYPE
#undef BODY_GET
#undef BODY_GET_TMP
#undef BODY_GET_BYKEY
#undef BODY_GET_TMP_BYKEY
#undef BODY_GET_BYINDEX

#define BODY_GET(name, type)			{ return name( STD_ARGS, PROV_ARGS, current        ); }
#define BODY_GET_TMP(name, type)		{ return name( STD_ARGS, PROV_ARGS                 ); }
#define BODY_GET_BYKEY(name, type)		{ return name( STD_ARGS, PROV_ARGS, current, key   ); }
#define BODY_GET_TMP_BYKEY(name, type)	{ return name( STD_ARGS, PROV_ARGS, key            ); }
#define BODY_GET_BYINDEX(name, type)	{ return name( STD_ARGS, PROV_ARGS, current, index ); }
#define ENUM_TYPE(dummy, real, type)	DECL_CFG_GET(int, dummy, real, type, DECL_DOT_PROV_ARGS(type))

ENUM_ARRAY_TYPES
ENUM_DUMMY_ARRAY_TYPES

#undef ENUM_TYPE
#undef BODY_GET
#undef BODY_GET_TMP
#undef BODY_GET_BYKEY
#undef BODY_GET_TMP_BYKEY
#undef BODY_GET_BYINDEX

/* ----- ProvSet ----- */

#define DECL_PROV_SET(name1, name2, type) \\
static inline int ProvSet##name1       ( DECL_STD_ARGS, const DECL_PROV_ARGS(type), OpBool apply, OpBool save              ) BODY_SET        (ProvSet##name2,        type) \\
static inline int ProvSetByKey##name1  ( DECL_STD_ARGS, const DECL_PROV_ARGS(type), OpBool apply, OpBool save, OpU16 key   ) BODY_SET_BYKEY  (ProvSetByKey##name2,   type) \\
static inline int ProvSetByIndex##name1( DECL_STD_ARGS, const DECL_PROV_ARGS(type), OpBool apply, OpBool save, OpU16 index ) BODY_SET_BYINDEX(ProvSetByIndex##name2, type)

#define BODY_SET(name, type)			\\
{ \\
	int rv; \\
	if (apply) rv = ProvisionDBSetEntryTmpApi(tag, id1, id2, dataSize, (void *)data); \\
	rv = ProvisionDBSetEntryNewApi(tag, id1, id2, dataSize, (void *)data, apply, save) || rv; \\
	return rv; \\
}
#define BODY_SET_BYKEY(name, type)		{ return ProvisionDBTableSetEntryByKeyApi(tag, id1, key, id2, dataSize, (void *)data, apply, save); }
#define BODY_SET_BYINDEX(name, type)	{ return ProvisionDBTableSetEntryByIndexApi(tag, id1, index, id2, dataSize, (void *)data, apply, save); }
#define ENUM_TYPE(dummy, real, type)	DECL_PROV_SET(real, real, type)

ENUM_BASIC_TYPES
ENUM_ARRAY_TYPES

#undef ENUM_TYPE
#undef BODY_SET
#undef BODY_SET_BYKEY
#undef BODY_SET_BYINDEX

#define BODY_SET(name, type)			{ return name( STD_ARGS, PROV_ARGS, apply, save ); }
#define BODY_SET_BYKEY(name, type)		{ return name( STD_ARGS, PROV_ARGS, apply, save, key ); }
#define BODY_SET_BYINDEX(name, type)	{ return name( STD_ARGS, PROV_ARGS, apply, save, index ); }
#define ENUM_TYPE(dummy, real, type)	DECL_PROV_SET(dummy, real, type)

ENUM_DUMMY_BASIC_TYPES
ENUM_DUMMY_ARRAY_TYPES

#undef ENUM_TYPE
#undef BODY_SET
#undef BODY_SET_BYKEY
#undef BODY_SET_BYINDEX

/* ----- CfgSet ----- */

#define DECL_CFG_SET(name1, name2, type, ...) \\
static inline int CfgSet##name1        ( DECL_STD_ARGS, __VA_ARGS__, OpBool apply, OpBool save              ) BODY_SET        (ProvSet##name2,        type) \\
static inline int CfgSetByKey##name1   ( DECL_STD_ARGS, __VA_ARGS__, OpBool apply, OpBool save, OpU16 key   ) BODY_SET_BYKEY  (ProvSetByKey##name2,   type) \\
static inline int CfgSetByIndex##name1 ( DECL_STD_ARGS, __VA_ARGS__, OpBool apply, OpBool save, OpU16 index ) BODY_SET_BYINDEX(ProvSetByIndex##name2, type)

#define BODY_SET(name, type)			{ return name( STD_ARGS, &data, sizeof (data), apply, save        ); }
#define BODY_SET_BYKEY(name, type)		{ return name( STD_ARGS, &data, sizeof (data), apply, save, key   ); }
#define BODY_SET_BYINDEX(name, type)	{ return name( STD_ARGS, &data, sizeof (data), apply, save, index ); }
#define ENUM_TYPE(dummy, real, type)	DECL_CFG_SET(dummy, real, type, type data)

ENUM_BASIC_TYPES
ENUM_DUMMY_BASIC_TYPES

#undef ENUM_TYPE
#undef BODY_SET
#undef BODY_SET_BYKEY
#undef BODY_SET_BYINDEX

#define BODY_SET(name, type)			{ return name( STD_ARGS, PROV_ARGS, apply, save        ); }
#define BODY_SET_BYKEY(name, type)		{ return name( STD_ARGS, PROV_ARGS, apply, save, key   ); }
#define BODY_SET_BYINDEX(name, type)	{ return name( STD_ARGS, PROV_ARGS, apply, save, index ); }
#define ENUM_TYPE(dummy, real, type)	DECL_CFG_SET(dummy, real, type, DECL_PROV_ARGS(type))

ENUM_ARRAY_TYPES
ENUM_DUMMY_ARRAY_TYPES

#undef ENUM_TYPE
#undef BODY_SET
#undef BODY_SET_BYKEY
#undef BODY_SET_BYINDEX

EOF
}

end_if()
{
cat << EOF
#endif

EOF
}

source_prologue()
{
cat << EOF
/*
 * Auto-generated by $BASH_SOURCE
 * date: $date
 *
 * DO NOT MODIFY.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "$1"

static void mcpAddU8(OpU8 *pBuf, OpU16 *pOffset, OpU16 id, OpU8 data, OpU8 lenSize) {

	OpU16 offset = *pOffset;

	pBuf[offset++] = GET_U16_BYTE1(id);
	pBuf[offset++] = GET_U16_BYTE2(id);
	if (lenSize == 2)
	{
		pBuf[offset++] = GET_U16_BYTE1(1);
		pBuf[offset++] = GET_U16_BYTE2(1);
	}
	else if (lenSize == 1)
		pBuf[offset++] = 1;
	pBuf[offset++] = data;

	*pOffset = offset;
}

static void mcpAddU16(OpU8 *pBuf, OpU16 *pOffset, OpU16 id, OpU16 data, OpU8 lenSize) {

	OpU16 offset = *pOffset;

	pBuf[offset++] = GET_U16_BYTE1(id);
	pBuf[offset++] = GET_U16_BYTE2(id);
	if (lenSize == 2)
	{
		pBuf[offset++] = GET_U16_BYTE1(2);
		pBuf[offset++] = GET_U16_BYTE2(2);
	}
	else if (lenSize == 1)
		pBuf[offset++] = 2;
	pBuf[offset++] = GET_U16_BYTE1(data);
	pBuf[offset++] = GET_U16_BYTE2(data);

	*pOffset = offset;
}

static void mcpAddS16(OpU8 *pBuf, OpU16 *pOffset, OpU16 id, OpS16 data, OpU8 lenSize) {

	OpU16 offset = *pOffset;

	pBuf[offset++] = GET_U16_BYTE1(id);
	pBuf[offset++] = GET_U16_BYTE2(id);
	if (lenSize == 2)
	{
		pBuf[offset++] = GET_U16_BYTE1(2);
		pBuf[offset++] = GET_U16_BYTE2(2);
	}
	else if (lenSize == 1)
		pBuf[offset++] = 2;
	pBuf[offset++] = GET_U16_BYTE1(data);
	pBuf[offset++] = GET_U16_BYTE2(data);

	*pOffset = offset;
}

static void mcpAddU32(OpU8 *pBuf, OpU16 *pOffset, OpU16 id, OpU32 data, OpU8 lenSize) {

	OpU16 offset = *pOffset;

	pBuf[offset++] = GET_U16_BYTE1(id);
	pBuf[offset++] = GET_U16_BYTE2(id);
	if (lenSize == 2)
	{
		pBuf[offset++] = GET_U16_BYTE1(4);
		pBuf[offset++] = GET_U16_BYTE2(4);
	}
	else if (lenSize == 1)
		pBuf[offset++] = 4;
	pBuf[offset++] = GET_U32_BYTE1(data);
	pBuf[offset++] = GET_U32_BYTE2(data);
	pBuf[offset++] = GET_U32_BYTE3(data);
	pBuf[offset++] = GET_U32_BYTE4(data);

	*pOffset = offset;
}

static void mcpAddMAC(OpU8 *pBuf, OpU16 *pOffset, OpU16 id, const OpU8 * data, OpU8 lenSize) {
	OpU16 offset = *pOffset;

	pBuf[offset++] = GET_U16_BYTE1(id);
	pBuf[offset++] = GET_U16_BYTE2(id);
	if (lenSize == 2)
	{
		pBuf[offset++] = GET_U16_BYTE1(6);
		pBuf[offset++] = GET_U16_BYTE2(6);
	}
	else if (lenSize == 1)
		pBuf[offset++] = 6;
	memcpy( pBuf+offset, data, 6 );

	*pOffset = offset + 6;
}

static void mcpAddSTRING(OpU8 *pBuf, OpU16 *pOffset, OpU16 id, const char * data, OpU8 lenSize) {

	OpU16 offset = *pOffset;
	OpU16 size;

	pBuf[offset++] = GET_U16_BYTE1(id);
	pBuf[offset++] = GET_U16_BYTE2(id);

	size = sprintf(pBuf+offset+2, "%s", data) + 1;
	if (lenSize == 2)
	{
		pBuf[offset++] = GET_U16_BYTE1(size);
		pBuf[offset++] = GET_U16_BYTE2(size);
	}
	else if (lenSize == 1)
		pBuf[offset++] = size;

	*pOffset = offset + size;
}

static void mcpAddFLOAT(OpU8 *pBuf, OpU16 *pOffset, OpU16 id, FLOAT data, OpU8 lenSize) {

	char value[32];

	FLOAT2MCP( data, value );
	mcpAddSTRING( pBuf, pOffset, id, value, lenSize );
}

#define mcpAddABLE			mcpAddU8
#define mcpAddYN			mcpAddU8
#define mcpAddIPV4			mcpAddU32
#define mcpAddIPV4MASK		mcpAddU32
#define mcpAddLIST			mcpAddU32
#define mcpAddRELATION		mcpAddU32
#define mcpAddFILESELECT	mcpAddSTRING
#define mcpAddPASSWD		mcpAddSTRING

#define MCP_GET_U8(p)		(*(OpU8 *)(p))
#define MCP_GET_U16(p)		ntohsGet(p)
#define MCP_GET_U32(p)		ntohlGet(p)
#define MCP_GET_S8(p)		(*(OpS8 *)(p))
#define MCP_GET_S16(p)		ntohGetS(2,(p))
#define MCP_GET_S32(p)		ntohGetS(4,(p))
#define MCP_GET_FLOAT(p)		MCP2FLOAT(p)
#define MCP_GET_MAC(p, mac)		memcpy((mac),(p),6)
#define MCP_GET_STRING(p, s, l)	{strncpy((s),(p),(l)-1); (s)[(l)-1]='\\0';}

#define MCP_GET_ABLE			MCP_GET_U8
#define MCP_GET_YN				MCP_GET_U8
#define MCP_GET_IPV4			MCP_GET_U32
#define MCP_GET_IPV4MASK		MCP_GET_U32
#define MCP_GET_LIST			MCP_GET_U32
#define MCP_GET_RELATION		MCP_GET_U32
#define MCP_GET_FILESELECT		MCP_GET_STRING
#define MCP_GET_PASSWD			MCP_GET_STRING

#define PTR_TO_U8(p,v,s)		*v=(*(OpU8 *)(p))
#define PTR_TO_U16(p,v,s)		memcpy((v),(p),sizeof(OpU16))
#define PTR_TO_U32(p,v,s)		memcpy((v),(p),sizeof(OpU32))
#define PTR_TO_S8(p,v,s)		*v=(*(OpS8 *)(p))
#define PTR_TO_S16(p,v,s)		memcpy((v),(p),sizeof(OpS16))
#define PTR_TO_S32(p,v,s)		memcpy((v),(p),sizeof(OpS32))
#define PTR_TO_FLOAT(p,v,s)		memcpy((v),(p),sizeof(FLOAT))
#define PTR_TO_MAC(p, mac, s)	memcpy((mac),(p),6)
#define PTR_TO_STRING(p, s, l)	{strncpy((s),(p),(l)-1); (s)[(l)-1]='\\0';}

#define PTR_TO_ABLE				PTR_TO_U8
#define PTR_TO_YN				PTR_TO_U8
#define PTR_TO_IPV4				PTR_TO_U32
#define PTR_TO_IPV4MASK			PTR_TO_U32
#define PTR_TO_LIST				PTR_TO_U32
#define PTR_TO_RELATION			PTR_TO_U32
#define PTR_TO_FILESELECT		PTR_TO_STRING
#define PTR_TO_PASSWD			PTR_TO_STRING

#define PROV_GET_BODY( type, provGet, getValue ) \\
{ \\
	OpU16 size; \\
	void * pData = NULL; \\
	int rv = provGet; \\
	\\
	if (pData == NULL) \\
		return -1; \\
	else if (rv == 0) \\
	{ \\
		getValue; \\
		OpfreeApi(pData); \\
	} \\
	\\
	return rv; \\
}

#define BODY_GET(name, type)			PROV_GET_BODY( type, \\
											ProvisionDBGetEntryApi( tag, id1, id2, &size, &pData, current ), \\
											PTR_TO_##name(pData, data, dataSize) )
#define BODY_GET_TMP(name, type)		PROV_GET_BODY( type, \\
											ProvisionDBGetEntryTmpApi( tag, id1, id2, &size, &pData ), \\
											PTR_TO_##name(pData, data, dataSize) )
#define BODY_GET_BYKEY(name, type)		PROV_GET_BODY( type, \\
											ProvisionDBTableGetEntryByKeyApi( tag, id1, key, id2, &size, &pData, current ), \\
											PTR_TO_##name(pData, data, dataSize) )
#define BODY_GET_TMP_BYKEY(name, type)	PROV_GET_BODY( type, \\
											ProvisionDBTableGetEntryTmpByKeyApi( tag, id1, key, id2, &size, &pData ), \\
											PTR_TO_##name(pData, data, dataSize) )
#define BODY_GET_BYINDEX(name, type)	PROV_GET_BODY( type, \\
											ProvisionDBTableGetEntryByIndexApi( tag, id1, index, id2, &size, &pData, current ), \\
											PTR_TO_##name(pData, data, dataSize) )
#define ENUM_TYPE(dummy, real, type)	DECL_PROV_GET(int, real, real, type)

ENUM_BASIC_TYPES
ENUM_ARRAY_TYPES

#undef ENUM_TYPE
#undef BODY_GET
#undef BODY_GET_TMP
#undef BODY_GET_BYKEY
#undef BODY_GET_TMP_BYKEY
#undef BODY_GET_BYINDEX

EOF
}

xquery()
{
	if [ "$RUN_OR_SOURCE" = "RUN" ]; then
		./basex -bxmldoc="$1" -bouttype=$2 cfg_wrapper.xq
	else
		. ./basex -bxmldoc="$1" -bouttype=$2 cfg_wrapper.xq
	fi
}

[ -f "$1" ] && {
	[ -n "$2" ] && { enum_prologue && xquery "$1" enum && end_if; } > "$2";
	[ -n "$3" ] && {
		{ header_prologue && xquery "$1" header && end_if; } > "$3";
		[ -n "$4" ] && { source_prologue "$(basename "$3")" && xquery "$1" 'source'; } > "$4";
	};
	true;
} || echo "Usage: $0 xml [enum [header [source]]]"

